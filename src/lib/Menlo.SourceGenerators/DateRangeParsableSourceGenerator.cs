using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Collections.Generic;
using System.Linq;

namespace Menlo.SourceGenerators;

[Generator]
public class DateRangeParsableSourceGenerator : ISourceGenerator
{
    public void Initialize(GeneratorInitializationContext context)
    {
        context.RegisterForSyntaxNotifications(() => new DateRangeParsableSyntaxReceiver());
    }

    public void Execute(GeneratorExecutionContext context)
    {
        var syntaxReceiver = context.SyntaxReceiver as DateRangeParsableSyntaxReceiver ??
                             new DateRangeParsableSyntaxReceiver();

        foreach (var recordToAugment in syntaxReceiver.RecordsToAugment.OfType<RecordDeclarationSyntax>())
        {
            ProcessClass(context, recordToAugment);
        }
    }

    private static void ProcessClass(GeneratorExecutionContext context, RecordDeclarationSyntax recordSyntax)
    {
        if (recordSyntax.Identifier.SyntaxTree is null)
        {
            return;
        }

        SemanticModel model = context.Compilation.GetSemanticModel(recordSyntax.Identifier.SyntaxTree);
        ISymbol? recordSymbol = model.GetDeclaredSymbol(recordSyntax);
        if (recordSymbol is null)
        {
            return;
        }

        string source =
            $$"""
              // <auto-generated />
              using Menlo.Common;
              using System;
              using System.Globalization;
              using System.Collections.Specialized;
              using System.Diagnostics.CodeAnalysis;
              using System.Web;
              using System.Xml;

              namespace {{recordSymbol.ContainingNamespace.ToDisplayString()}};

              #nullable enable

              public partial record {{recordSymbol.Name}}(DateOnly StartDate, DateOnly? EndDate = null, TimeSpan TimeZone = default)
              : DateRangeQuery(StartDate, EndDate, TimeZone), IParsable<{{recordSymbol.Name}}>
              {
                  public const string DefaultDuration = "P7D";

                  public static {{recordSymbol.Name}} Parse(string query, IFormatProvider? provider)
                  {
                      NameValueCollection parameters = HttpUtility.ParseQueryString(query);

                      string? endDateValue = parameters.GetValues("endDate")?.Last();
                      DateOnly endDate = string.IsNullOrEmpty(endDateValue)
                          ? DateOnly.FromDateTime(DateTime.Today)
                          : DateOnly.Parse(endDateValue, provider);

                      string startDateValue = parameters.GetValues("startDate")?.Last() ?? DefaultDuration;
                      TimeSpan? duration = GetDuration(startDateValue);
                      DateOnly startDate;
                      if (duration is null)
                      {
                          startDate = DateOnly.Parse(startDateValue, provider);
                      }
                      else
                      {
                          startDate = new DateOnly(endDate.Year, endDate.Month, endDate.Day);
                          startDate = SubtractDuration(startDate, duration.Value);
                      }

                      string[]? timeZoneValues = parameters.GetValues("timeZone");

                      TimeSpan timeZone = timeZoneValues == null
                          ? default
                          : TimeZoneInfo.FindSystemTimeZoneById(timeZoneValues.Last()).BaseUtcOffset;

                      return new {{recordSymbol.Name}}(startDate, endDate, timeZone);
                  }

                  public static bool TryParse(
                      [NotNullWhen(true)] string? query,
                      IFormatProvider? provider,
                      [MaybeNullWhen(false)] out {{recordSymbol.Name}} result)
                  {
                      if (string.IsNullOrEmpty(query))
                      {
                          result = null;
                          return false;
                      }

                      result = Parse(query, provider);
                      return true;
                  }

                  public static bool TryParse(
                      [NotNullWhen(true)] string? query,
                      [MaybeNullWhen(false)] out {{recordSymbol.Name}} result)
                  {
                      return TryParse(query, CultureInfo.CurrentCulture, out result);
                  }

                  private static TimeSpan? GetDuration(string value)
                  {
                      try
                      {
                          return XmlConvert.ToTimeSpan(value);
                      }
                      catch (FormatException)
                      {
                          return null;
                      }
                  }

                  private static DateOnly SubtractDuration(DateOnly date, TimeSpan duration)
                  {
                      return date.AddDays(-duration.Days);
                  }
              }
              """;

        context.AddSource($"{recordSymbol.Name}.Parsable.cs", source);
    }

    private class DateRangeParsableSyntaxReceiver : ISyntaxReceiver
    {
        public List<RecordDeclarationSyntax?> RecordsToAugment { get; } = [];

        public void OnVisitSyntaxNode(SyntaxNode syntaxNode)
        {
            if (syntaxNode is not RecordDeclarationSyntax cds)
            {
                return;
            }

            foreach (AttributeListSyntax attributeList in cds.AttributeLists)
            {
                foreach (AttributeSyntax attribute in attributeList.Attributes)
                {
                    if (attribute.Name is not IdentifierNameSyntax identifier)
                    {
                        continue;
                    }

                    if (identifier.Identifier.ValueText == "DateRangeParsable")
                    {
                        RecordsToAugment.Add(cds);
                    }
                }
            }
        }
    }
}
