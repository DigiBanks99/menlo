using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System;
using System.Linq;

namespace Menlo.SourceGenerators;

/// <summary>
/// Model that holds the record declaration and its symbol for source generation
/// </summary>
internal class RecordToGenerate
{
    public INamedTypeSymbol RecordSymbol { get; set; } = null!;
}

[Generator]
public sealed class DateRangeParsableSourceGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Register for records with the DateRangeParsable attribute
        IncrementalValuesProvider<RecordDeclarationSyntax> recordDeclarations = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (s, _) => s is RecordDeclarationSyntax r && r.AttributeLists.Count > 0,
                transform: static (ctx, _) =>
                    GetRecordIfHasDateRangeParsableAttribute(ctx.Node as RecordDeclarationSyntax))
            .Where(static m => m is not null)!;

        // Combine with compilation to get the semantic model information
        IncrementalValuesProvider<RecordToGenerate> recordsWithSymbols = recordDeclarations
            .Combine(context.CompilationProvider)
            .Select((tuple, _) => GetRecordSymbolInfo(tuple.Left, tuple.Right))
            .Where(static m => m is not null)!;

        // Generate the source
        context.RegisterSourceOutput(recordsWithSymbols, GenerateSource);
    }

    private static RecordDeclarationSyntax? GetRecordIfHasDateRangeParsableAttribute(
        RecordDeclarationSyntax? recordSyntax)
    {
        if (recordSyntax == null)
            return null;

        foreach (var attribute in recordSyntax.AttributeLists.SelectMany(attributeList => attributeList.Attributes))
        {
            if (attribute.Name is IdentifierNameSyntax identifier &&
                identifier.Identifier.ValueText.Equals("DateRangeParsable", StringComparison.InvariantCulture))
            {
                return recordSyntax;
            }
        }

        return null;
    }

    private static RecordToGenerate? GetRecordSymbolInfo(RecordDeclarationSyntax recordSyntax, Compilation compilation)
    {
        if (recordSyntax.Identifier.SyntaxTree is null)
        {
            return null;
        }

        SemanticModel model = compilation.GetSemanticModel(recordSyntax.Identifier.SyntaxTree);
        return model.GetDeclaredSymbol(recordSyntax) is not INamedTypeSymbol recordSymbol
            ? null
            : new RecordToGenerate()
            {
                RecordSymbol = recordSymbol
            };
    }

    private static void GenerateSource(SourceProductionContext context, RecordToGenerate record)
    {
        var recordSymbol = record.RecordSymbol;

        string source =
            $$"""
              // <auto-generated />
              using Menlo.Common;
              using System;
              using System.Globalization;
              using System.Collections.Specialized;
              using System.Diagnostics.CodeAnalysis;
              using System.Web;
              using System.Xml;

              namespace {{recordSymbol.ContainingNamespace.ToDisplayString()}};

              #nullable enable

              public partial record {{recordSymbol.Name}}(DateOnly StartDate, DateOnly? EndDate = null, TimeSpan TimeZone = default)
              : DateRangeQuery(StartDate, EndDate, TimeZone), IParsable<{{recordSymbol.Name}}>
              {
                  public const string DefaultDuration = "P7D";

                  public static {{recordSymbol.Name}} Parse(string query, IFormatProvider? provider)
                  {
                      NameValueCollection parameters = HttpUtility.ParseQueryString(query);

                      string? endDateValue = parameters.GetValues("endDate")?.Last();
                      DateOnly endDate = string.IsNullOrEmpty(endDateValue)
                          ? DateOnly.FromDateTime(DateTime.Today)
                          : DateOnly.Parse(endDateValue, provider);

                      string startDateValue = parameters.GetValues("startDate")?.Last() ?? DefaultDuration;
                      TimeSpan? duration = GetDuration(startDateValue);
                      DateOnly startDate;
                      if (duration is null)
                      {
                          startDate = DateOnly.Parse(startDateValue, provider);
                      }
                      else
                      {
                          startDate = new DateOnly(endDate.Year, endDate.Month, endDate.Day);
                          startDate = SubtractDuration(startDate, duration.Value);
                      }

                      string[]? timeZoneValues = parameters.GetValues("timeZone");

                      TimeSpan timeZone = timeZoneValues == null
                          ? default
                          : TimeZoneInfo.FindSystemTimeZoneById(timeZoneValues.Last()).BaseUtcOffset;

                      return new {{recordSymbol.Name}}(startDate, endDate, timeZone);
                  }

                  public static bool TryParse(
                      [NotNullWhen(true)] string? query,
                      IFormatProvider? provider,
                      [MaybeNullWhen(false)] out {{recordSymbol.Name}} result)
                  {
                      if (string.IsNullOrEmpty(query))
                      {
                          result = null;
                          return false;
                      }

                      result = Parse(query, provider);
                      return true;
                  }

                  public static bool TryParse(
                      [NotNullWhen(true)] string? query,
                      [MaybeNullWhen(false)] out {{recordSymbol.Name}} result)
                  {
                      return TryParse(query, CultureInfo.CurrentCulture, out result);
                  }

                  private static TimeSpan? GetDuration(string value)
                  {
                      try
                      {
                          return XmlConvert.ToTimeSpan(value);
                      }
                      catch (FormatException)
                      {
                          return null;
                      }
                  }

                  private static DateOnly SubtractDuration(DateOnly date, TimeSpan duration)
                  {
                      return date.AddDays(-duration.Days);
                  }
              }
              """;

        context.AddSource($"{recordSymbol.Name}.Parsable.cs", source);
    }
}
