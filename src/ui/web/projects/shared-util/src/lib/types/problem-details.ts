/**
 * @fileoverview ProblemDetails and ApiError types for Angular error handling.
 *
 * Implements RFC 7807 Problem Details and a discriminated union for API errors.
 * Provides conversion utilities to normalize various error types into a consistent format.
 *
 * @see https://datatracker.ietf.org/doc/html/rfc7807
 * @see https://learn.microsoft.com/en-us/aspnet/core/web-api/handle-errors
 */

// ============================================================================
// HttpErrorResponse-like Interface (for duck typing)
// ============================================================================

/**
 * Duck-typed interface matching Angular's HttpErrorResponse structure.
 * This allows the library to work without a direct dependency on @angular/common/http
 * at runtime, enabling pure TypeScript testing.
 */
interface HttpErrorResponseLike {
  readonly name: string;
  readonly status: number;
  readonly statusText?: string;
  readonly error: unknown;
  readonly message?: string;
  readonly url?: string | null;
  readonly ok?: boolean;
}

/**
 * Type guard to check if an error is HttpErrorResponse-like.
 */
function isHttpErrorResponseLike(error: unknown): error is HttpErrorResponseLike {
  return (
    typeof error === 'object' &&
    error !== null &&
    'name' in error &&
    (error as Record<string, unknown>)['name'] === 'HttpErrorResponse' &&
    'status' in error &&
    typeof (error as Record<string, unknown>)['status'] === 'number' &&
    'error' in error
  );
}

// ============================================================================
// ProblemDetails Type (RFC 7807)
// ============================================================================

/**
 * RFC 7807 Problem Details for HTTP APIs.
 * Also includes ASP.NET Core extensions.
 *
 * @see https://datatracker.ietf.org/doc/html/rfc7807
 *
 * @example
 * ```json
 * {
 *   "type": "https://example.com/probs/out-of-credit",
 *   "title": "You do not have enough credit.",
 *   "status": 403,
 *   "detail": "Your current balance is 30, but that costs 50.",
 *   "instance": "/account/12345/msgs/abc",
 *   "errors": {
 *     "Name": ["Name is required", "Name must be at least 3 characters"]
 *   }
 * }
 * ```
 */
export interface ProblemDetails {
  /**
   * A URI reference that identifies the problem type.
   * When dereferenced, it should provide human-readable documentation.
   */
  readonly type?: string;

  /**
   * A short, human-readable summary of the problem type.
   * Should not change from occurrence to occurrence.
   */
  readonly title?: string;

  /**
   * The HTTP status code generated by the origin server.
   */
  readonly status?: number;

  /**
   * A human-readable explanation specific to this occurrence.
   */
  readonly detail?: string;

  /**
   * A URI reference that identifies the specific occurrence.
   */
  readonly instance?: string;

  /**
   * ASP.NET Core extension: Validation errors keyed by field name.
   * Field names are typically in PascalCase as sent by the server.
   */
  readonly errors?: Record<string, string[]>;

  /**
   * ASP.NET Core extension: Request trace identifier.
   */
  readonly traceId?: string;

  /**
   * Extension members - allows additional properties.
   */
  [key: string]: unknown;
}

// ============================================================================
// ApiError Discriminated Union
// ============================================================================

/**
 * Represents a problem-based API error with ProblemDetails payload.
 * Used for 4xx/5xx responses that include ProblemDetails in the body.
 */
export interface ProblemApiError {
  readonly kind: 'problem';
  readonly problem: ProblemDetails;
  readonly status?: number;
}

/**
 * Represents a network-level error (connectivity, CORS, timeout, etc.).
 * Used when the request didn't reach the server or received a non-ProblemDetails error.
 */
export interface NetworkApiError {
  readonly kind: 'network';
  readonly status?: number;
  readonly message: string;
  readonly originalError?: unknown;
}

/**
 * Represents an unknown error that couldn't be classified.
 * Used as a fallback for unexpected error types.
 */
export interface UnknownApiError {
  readonly kind: 'unknown';
  readonly message: string;
  readonly originalError?: unknown;
}

/**
 * Discriminated union of all API error types.
 * Use the `kind` property to narrow the type.
 *
 * @example
 * ```typescript
 * function handleError(error: ApiError): void {
 *   switch (error.kind) {
 *     case 'problem':
 *       console.log('Problem:', error.problem.title);
 *       break;
 *     case 'network':
 *       console.log('Network error:', error.message);
 *       break;
 *     case 'unknown':
 *       console.log('Unknown error:', error.message);
 *       break;
 *   }
 * }
 * ```
 */
export type ApiError = ProblemApiError | NetworkApiError | UnknownApiError;

// ============================================================================
// Factory Functions
// ============================================================================

/**
 * Creates a problem-based API error.
 *
 * @param problem - The ProblemDetails payload
 * @param status - Optional HTTP status code (defaults to problem.status)
 * @returns A ProblemApiError
 */
export function problemError(
  problem: ProblemDetails,
  status?: number
): ProblemApiError {
  return {
    kind: 'problem',
    problem,
    status: status ?? problem.status,
  };
}

/**
 * Creates a network-level API error.
 *
 * @param status - Optional HTTP status code
 * @param message - Error message (defaults to 'Network error')
 * @param originalError - The original error object
 * @returns A NetworkApiError
 */
export function networkError(
  status?: number,
  message?: string,
  originalError?: unknown
): NetworkApiError {
  return {
    kind: 'network',
    status,
    message: message ?? 'Network error',
    originalError,
  };
}

/**
 * Creates an unknown API error.
 *
 * @param message - Error message (defaults to 'An unexpected error occurred')
 * @param originalError - The original error object
 * @returns An UnknownApiError
 */
export function unknownError(
  message?: string,
  originalError?: unknown
): UnknownApiError {
  return {
    kind: 'unknown',
    message: message ?? 'An unexpected error occurred',
    originalError,
  };
}

// ============================================================================
// Type Guards
// ============================================================================

/**
 * Checks if an error is a ProblemApiError.
 */
export function isProblemError(error: ApiError): error is ProblemApiError {
  return error.kind === 'problem';
}

/**
 * Checks if an error is a NetworkApiError.
 */
export function isNetworkError(error: ApiError): error is NetworkApiError {
  return error.kind === 'network';
}

/**
 * Checks if an error is an UnknownApiError.
 */
export function isUnknownError(error: ApiError): error is UnknownApiError {
  return error.kind === 'unknown';
}

// ============================================================================
// Conversion Functions
// ============================================================================

/**
 * Checks if an object looks like ProblemDetails.
 * Looks for common properties defined in RFC 7807.
 */
function isProblemDetails(obj: unknown): obj is ProblemDetails {
  if (typeof obj !== 'object' || obj === null) {
    return false;
  }

  const candidate = obj as Record<string, unknown>;

  // Must have at least one of the standard ProblemDetails properties
  return (
    typeof candidate['type'] === 'string' ||
    typeof candidate['title'] === 'string' ||
    typeof candidate['status'] === 'number' ||
    typeof candidate['detail'] === 'string' ||
    typeof candidate['errors'] === 'object'
  );
}

/**
 * Extracts an error message from various error types.
 */
function extractErrorMessage(error: unknown): string {
  if (error instanceof Error) {
    return error.message;
  }
  if (typeof error === 'string') {
    return error;
  }
  if (
    typeof error === 'object' &&
    error !== null &&
    'message' in error &&
    typeof (error as Record<string, unknown>)['message'] === 'string'
  ) {
    return (error as Record<string, unknown>)['message'] as string;
  }
  return 'An unexpected error occurred';
}

/**
 * Converts any error type into a normalized ApiError.
 *
 * Handles:
 * - HttpErrorResponse with ProblemDetails body → ProblemApiError
 * - HttpErrorResponse without ProblemDetails → NetworkApiError
 * - Network connectivity errors (status 0) → NetworkApiError
 * - Generic Error objects → UnknownApiError
 * - Unknown types → UnknownApiError
 *
 * @param error - The error to convert
 * @returns A normalized ApiError
 *
 * @example
 * ```typescript
 * // In an HttpClient error handler
 * catchError(error => {
 *   const apiError = toApiError(error);
 *   return of(failure(apiError));
 * })
 * ```
 */
export function toApiError(error: unknown): ApiError {
  // Handle HttpErrorResponse from Angular HttpClient (using duck typing)
  if (isHttpErrorResponseLike(error)) {
    // Check for network-level errors (no connection, CORS, etc.)
    if (error.status === 0) {
      return networkError(
        0,
        'Unable to connect to the server. Please check your internet connection.',
        error
      );
    }

    // Check if the error body contains ProblemDetails
    if (isProblemDetails(error.error)) {
      return problemError(error.error as ProblemDetails, error.status);
    }

    // Check if error.error is a string message
    if (typeof error.error === 'string' && error.error.length > 0) {
      // Try to parse as JSON (might be stringified ProblemDetails)
      try {
        const parsed = JSON.parse(error.error);
        if (isProblemDetails(parsed)) {
          return problemError(parsed, error.status);
        }
      } catch {
        // Not JSON, treat as plain text message
      }
    }

    // Fallback to network error for non-ProblemDetails HTTP errors
    return networkError(
      error.status,
      error.message || `HTTP Error ${error.status}`,
      error
    );
  }

  // Handle standard Error objects
  if (error instanceof Error) {
    return unknownError(error.message, error);
  }

  // Handle string errors
  if (typeof error === 'string') {
    return unknownError(error);
  }

  // Handle null/undefined
  if (error === null || error === undefined) {
    return unknownError('An unexpected error occurred');
  }

  // Handle unknown object types
  return unknownError(extractErrorMessage(error), error);
}

// ============================================================================
// Helper Functions
// ============================================================================

/**
 * Checks if an ApiError contains validation errors.
 * Only ProblemApiErrors with a populated `errors` field return true.
 *
 * @param error - The ApiError to check
 * @returns True if the error contains field-level validation errors
 *
 * @example
 * ```typescript
 * if (hasValidationErrors(error)) {
 *   // Map errors to form controls
 *   Object.entries(error.problem.errors!).forEach(([field, messages]) => {
 *     form.get(field)?.setErrors({ api: messages.join(', ') });
 *   });
 * }
 * ```
 */
export function hasValidationErrors(error: ApiError): boolean {
  if (error.kind !== 'problem') {
    return false;
  }

  const errors = error.problem.errors;
  return errors !== undefined && Object.keys(errors).length > 0;
}

/**
 * Extracts a user-friendly error message from an ApiError.
 *
 * Extraction priority for ProblemApiError:
 * 1. problem.detail
 * 2. problem.title
 * 3. problem.type
 * 4. Default message
 *
 * @param error - The ApiError to extract a message from
 * @param defaultMessage - Fallback message if none can be extracted
 * @returns A user-friendly error message
 *
 * @example
 * ```typescript
 * const message = getErrorMessage(error, 'Something went wrong');
 * snackbar.open(message, 'Dismiss');
 * ```
 */
export function getErrorMessage(
  error: ApiError,
  defaultMessage = 'An unexpected error occurred'
): string {
  switch (error.kind) {
    case 'problem': {
      const { problem } = error;
      // Try to get the most specific message
      if (problem.detail && problem.detail.trim().length > 0) {
        return problem.detail;
      }
      if (problem.title && problem.title.trim().length > 0) {
        return problem.title;
      }
      if (problem.type && problem.type.trim().length > 0) {
        return problem.type;
      }
      return defaultMessage;
    }
    case 'network':
    case 'unknown':
      return error.message || defaultMessage;
    default:
      return defaultMessage;
  }
}

/**
 * Gets the HTTP status code from an ApiError, if available.
 *
 * @param error - The ApiError to get status from
 * @returns The HTTP status code or undefined
 */
export function getErrorStatus(error: ApiError): number | undefined {
  switch (error.kind) {
    case 'problem':
      return error.status ?? error.problem.status;
    case 'network':
      return error.status;
    case 'unknown':
      return undefined;
    default:
      return undefined;
  }
}

/**
 * Gets validation errors from a ProblemApiError, converting field names to camelCase.
 *
 * Backend APIs typically return PascalCase field names (e.g., "UserName"),
 * while frontend forms use camelCase (e.g., "userName").
 *
 * @param error - The ApiError to get validation errors from
 * @returns A record of field names (camelCase) to error message arrays, or empty object
 *
 * @example
 * ```typescript
 * const errors = getValidationErrors(error);
 * // { userName: ['Name is required'], email: ['Invalid email format'] }
 * ```
 */
export function getValidationErrors(
  error: ApiError
): Record<string, string[]> {
  if (error.kind !== 'problem' || !error.problem.errors) {
    return {};
  }

  const result: Record<string, string[]> = {};

  for (const [key, messages] of Object.entries(error.problem.errors)) {
    // Convert PascalCase to camelCase
    const camelKey = key.charAt(0).toLowerCase() + key.slice(1);
    result[camelKey] = messages;
  }

  return result;
}

/**
 * Maps validation errors to Angular form controls.
 *
 * @param error - The ApiError containing validation errors
 * @param form - The FormGroup to map errors to
 * @param options - Optional configuration
 *
 * @example
 * ```typescript
 * import { FormGroup } from '@angular/forms';
 *
 * const form = new FormGroup({ ... });
 * mapValidationErrorsToForm(error, form);
 * // Form controls now have 'api' errors set
 * ```
 */
export function mapValidationErrorsToForm(
  error: ApiError,
  form: { get(path: string): { setErrors(errors: object): void; markAsTouched(): void } | null },
  options: { markAsTouched?: boolean } = { markAsTouched: true }
): void {
  const errors = getValidationErrors(error);

  for (const [fieldName, messages] of Object.entries(errors)) {
    const control = form.get(fieldName);
    if (control) {
      control.setErrors({ api: messages.join(', ') });
      if (options.markAsTouched) {
        control.markAsTouched();
      }
    }
  }
}
